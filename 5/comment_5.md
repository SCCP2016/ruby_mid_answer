それぞれ引数に配列を受け取り、一つの値を返す関数である。
いずれも値を求めるために畳み込みを利用するのが良い。

**min** ... アキュムレータとして現在までの最小値を保持し、畳み込みで最小値を都度更新する。配列の要素の値を順に評価していくときに、その値がアキュムレータの値よりも小さいときにはアキュムレータの値を更新するようにすると最後にはアキュムレータに対して配列内の最小の要素の値が入っていることになる。

**max** ... 評価の条件式をminと逆にすれば最大値が求められることが分かる。

**sum** ... アキュムレータに合計値を蓄積し、畳み込みで加算していく。最もスタンダードな畳み込みの例である。

![inject](http://cdn-ak.f.st-hatena.com/images/fotolife/s/succzero/20131207/20131207233749.png)

```
arr = STDIN.gets.split.map(&:to_i)

# 畳み込みを利用して配列内の最小値を求める
def min(arr)
    arr.inject{ |min_val, n| min_val > n ? n : min_val }
end

# 畳み込みを利用して配列内の最大値を求める
def max(arr)
    arr.inject{ |min_val, n| min_val < n ? n : min_val }
end

# 畳み込みを利用して配列の要素の値の合計値を求める
def sum(arr)
    arr.inject{ |sum, n| sum + n }
end

p min(arr)
p max(arr)
p sum(arr)
```

1から5までの整数を畳み込みを使って累算する例を以下に示す

```
acc: 0
[1, 2, 3, 4, 5]

acc: 1 = 0+1
[2, 3, 4, 5]

acc: 3 = 1+2
[3, 4, 5]

acc: 6 = 3+3
[4, 5]

acc: 10 = 6+4
[5]

acc: 15 = 10+5
[]

acc: 15
```